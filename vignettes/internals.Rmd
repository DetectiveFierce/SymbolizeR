---
title: "Package Internals"
output: 
  rmarkdown::html_vignette:
    css: vignette-theme.css
    includes:
      after_body: vignette-extras.html
vignette: >
  %\VignetteIndexEntry{Package Internals}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>"
)
```

This vignette provides a **technical deep-dive** into SymbolizeR's architecture. It explains how expressions are parsed, transformed, and simplified internally.

```{r setup}
library(SymbolizeR)
```

---

## Architecture Overview

SymbolizeR is built around **R's native expression tree representation**. The core insight is that unevaluated R code (captured via `substitute()` or `quote()`) is a tree structure that we can traverse and transform.

```
User Call: E(a * X + b)
    │
    ▼
┌────────────────────────────┐
│  Expression Tree Capture   │  ← substitute(expr) captures unevaluated AST
└────────────────────────────┘
    │
    ▼
┌────────────────────────────┐
│  Type Classification       │  ← classify.type() distinguishes RV/const/number
└────────────────────────────┘
    │
    ▼
┌────────────────────────────┐
│  Recursive Transformation  │  ← expect.recursive() applies linearity rules
└────────────────────────────┘
    │
    ▼
┌────────────────────────────┐
│  Distribution Lookup       │  ← get.first.moment() substitutes known E[X]
└────────────────────────────┘
    │
    ▼
┌────────────────────────────┐
│  Expression Simplification │  ← simplify.expr() removes identity elements
└────────────────────────────┘
    │
    ▼
Output: a * E(X) + b  (or a * mu + b if X ~ Normal(mu, sigma))
```

---

## File Organization

The R source files are numbered by dependency order:

| File | Purpose |
|------|---------|
| `00_utils.R` | Core utilities: `classify.type`, `ensure.expression`, `expand.poly` |
| `01_internal_expect.R` | Expectation engine: `expect.recursive` |
| `02_internal_simplify.R` | Simplification: `simplify.expr` |
| `03_user_wrappers.R` | Public API: `E()`, `Var()`, `Cov()`, `derive.*()` |
| `04_distributions.R` | Distribution registry: `define()`, moment getters, independence |
| `05_calculus.R` | Symbolic differentiation and integration |
| `06_latex.R` | LaTeX conversion: `to.latex()` |

---

## Expression Trees in R

R expressions are **abstract syntax trees (ASTs)**. Every unevaluated call is a list-like structure:

```{r ast}
# Capture an unevaluated expression
expr <- quote(a * X + b)

# The tree structure
is.call(expr)   # TRUE - it's a call object

# First element is the operator
expr[[1]]       # `+` (the function being called)

# Remaining elements are arguments
expr[[2]]       # a * X (left operand - itself a call)
expr[[3]]       # b (right operand - a symbol)
```

### Tree Visualization

For `a * X + b`, the AST looks like:

```
      (+)
     /   \
   (*)    b
  /   \
 a     X
```

We traverse this tree recursively, transforming nodes according to mathematical rules.

---

## Type Classification (`00_utils.R`)

The `classify.type()` function determines how to treat each node:

| Return Value | Condition | Example |
|--------------|-----------|---------|
| `"number"` | `is.numeric(sym)` | `5`, `2.5` |
| `"rv"` | Symbol starting with uppercase | `X`, `Y`, `Normal` |
| `"const"` | Symbol starting with lowercase | `a`, `mu`, `sigma` |
| `"call"` | Complex expression | `a * X`, `X + Y` |

```{r classify, eval=FALSE}
classify.type(quote(X))       # "rv"
classify.type(quote(mu))      # "const"
classify.type(5)              # "number"
classify.type(quote(a * X))   # "call"
```

This classification drives all downstream behavior: constants pass through unchanged, random variables get wrapped in `E()`, and nested calls recurse.

---

## The Expectation Engine (`01_internal_expect.R`)

The `expect.recursive()` function walks the expression tree, applying:

$$E[aX + b] = aE[X] + b \qquad E[X + Y] = E[X] + E[Y]$$

### Algorithm Pseudocode

```
expect.recursive(expr):
    if expr is numeric:
        return expr
    
    if expr is symbol:
        if lowercase (constant):
            return expr
        if uppercase (RV):
            if has known distribution:
                return first_moment
            else:
                return E(expr)
    
    if expr is call:
        op = operator of expr
        
        if op is '+' or '-':
            return op(expect.recursive(left), expect.recursive(right))
        
        if op is '*':
            classify both operands
            if const * RV:
                return const * expect.recursive(RV)
            if RV * RV:
                if independent:
                    return expect.recursive(left) * expect.recursive(right)
                else:
                    return E(left * right)  # cannot simplify
            ...
```

### Handling Products

The trickiest case is multiplication involving random variables:

```{r products}
# Constant * RV: factor out constant
E(a * X)

# RV * RV without independence: cannot factor
E(X * Y)

# With independence declared:
assume.independent(X, Y)
E(X * Y)
clear.independence()
```

---

## Expression Simplification (`02_internal_simplify.R`)

After transformation, `simplify.expr()` cleans up identity operations:

| Pattern | Simplifies To |
|---------|---------------|
| `x + 0` | `x` |
| `0 + x` | `x` |
| `x * 1` | `x` |
| `x * 0` | `0` |
| `x - 0` | `x` |
| `0 / x` | `0` |
| `x^0` | `1` |
| `x^1` | `x` |
| `E(constant)` | `constant` |

The simplifier also recurses into nested expressions, making multiple passes when needed:

```{r simplify, eval=FALSE}
# Internal call (not exported)
simplify.expr(quote(x + 0))    # x
simplify.expr(quote(1 * E(a))) # a (E of constant becomes constant)
```

---

## Polynomial Expansion (`00_utils.R`)

The `expand.poly()` function handles algebraic expansion for variance/covariance calculations:

```{r expand}
# Variance needs (aX + b)^2 expanded
Var(a * X + b)
```

Internally, `expand.poly()` applies:

$$(A + B)^2 = A^2 + 2AB + B^2$$
$$(A \cdot B)^n = A^n \cdot B^n$$

And distributes multiplication over addition:

$$A \cdot (B + C) = A \cdot B + A \cdot C$$

This expansion happens **before** the expectation engine runs, so `E()` sees individual terms rather than parenthesized powers.

---

## Distribution System (`04_distributions.R`)

### The Package Environment

Distributions are stored in a private environment `pkg.env`:

```{r define}
define(X ~ Normal(mu, sigma))
```

This stores:

```{r stored, eval=FALSE}
pkg.env$X = list(
  distribution = "Normal",
  params = list(mu = quote(mu), sigma = quote(sigma))
)
```

### Moment Lookup

When `expect.recursive()` encounters a registered variable, it calls:

- `get.first.moment(var_name)` → Returns symbolic E[X]
- `get.second.moment(var_name)` → Returns symbolic E[X²]
- `get.mgf(var_name, t)` → Returns M_X(t) = E[e^tX]

Each function uses a `switch()` on the distribution name to return the appropriate formula:

```{r moments}
define(X ~ Normal(mu, sigma))
E(X)      # mu (from get.first.moment)
E(X^2)    # sigma^2 + mu^2 (from get.second.moment)
clear.definitions()
```

### Independence Tracking

Independence is stored as pairs in `pkg.env$.independence_pairs`:

```{r independence2}
assume.independent(X, Y, Z)  # Creates pairs: X:Y, X:Z, Y:Z
show.independence()
clear.independence()
```

The `are.independent(x, y)` function checks if a pair exists in this list.

---

## Calculus Module (`05_calculus.R`)

### Symbolic Differentiation

`deriv.sym()` wraps `stats::D()` with special handling for `E()` calls:

```{r deriv}
deriv.sym(x^3, x)           # 3 * x^2
deriv.sym(x * E(Y), x)      # E(Y) - treats E(Y) as constant
```

The `protect.E()` / `restore.E()` pattern replaces `E(...)` with temp symbols `__E_...___` before calling `stats::D()`, then restores them after.

### Definite Integration

`integrate.sym()` uses **kernel recognition** rather than symbolic antiderivatives:

```{r integrate}
# Gamma kernel: x^a * exp(-bx)
integrate.sym(x^2 * exp(-x), x, 0, Inf)

# Gaussian kernel: exp(-ax^2)
integrate.sym(exp(-x^2), x, -Inf, Inf)

# Beta kernel: x^a * (1-x)^b
integrate.sym(x * (1-x), x, 0, 1)
```

The algorithm:

1. **Partition**: Separate constant factors from variable-dependent parts
2. **Match Kernel**: Try Gamma, Gaussian, or Beta patterns based on bounds
3. **Return**: Known normalizing constant × constant factor

If no kernel matches, an unevaluated `Integrate()` call is returned.

---

## LaTeX Conversion (`06_latex.R`)

The `to.latex()` S3 generic dispatches to `expr.to.latex()` for recursive conversion:

```{r latex}
to.latex(E(a * X + b))
to.latex(Var(X))
```

Key conversions:

| R Expression | LaTeX Output |
|--------------|--------------|
| `E(X)` | `\mathbb{E}[X]` |
| `Var(X)` | `\text{Var}(X)` |
| `a/b` | `\frac{a}{b}` |
| `x^2` | `x^{2}` |
| `sqrt(x)` | `\sqrt{x}` |
| `mu`, `sigma` | `\mu`, `\sigma` |

Greek letters are mapped via `.greek_letters`, and subscript notation (e.g., `X_1`) produces proper LaTeX subscripts.

---

## Summary: Data Flow

A complete call like `E(a * X + b)` flows through:

1. **Capture**: `substitute(expr)` → unevaluated AST
2. **Normalize**: `ensure.expression()` → consistent form
3. **Transform**: `expect.recursive()` → apply linearity
4. **Lookup**: `get.first.moment()` → substitute known moments
5. **Simplify**: `simplify.expr()` → remove identities
6. **Return**: Cleaned expression as R call object

The result remains an **unevaluated R expression**—not a string, not a number—which means it can be further manipulated, converted to LaTeX, or used in subsequent calculations.

---

<div class="vignette-nav">
  <a href="independence-latex.html" class="nav-item prev">
    <span class="nav-label">Previous</span>
    <span class="nav-title">5. Independence & LaTeX</span>
  </a>
  <div></div>
</div>
